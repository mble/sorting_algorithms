#![feature(libc)]
extern crate libc;
use std::mem;
use std::slice;

#[repr(C)]
pub struct RubyArray {
    len: libc::size_t,
    data: *const libc::c_void,
}

impl RubyArray {
    fn from_vec<T>(vec: Vec<T>) -> RubyArray {
        let array = RubyArray {
            data: vec.as_ptr() as *const libc::c_void,
            len: vec.len() as libc::size_t };
        mem::forget(vec);
        array
    }
}

#[no_mangle]
pub extern fn sum_of_even(n: *const libc::uint32_t, len: libc::size_t) -> libc::uint32_t {
    let numbers = unsafe {
        assert!(!n.is_null());

        slice::from_raw_parts(n, len as usize)
    };

    let sum =
        numbers.iter()
        .filter(|&v| v % 2 == 0)
        .fold(0, |acc, v| acc + v);
    sum as libc::uint32_t
}

#[no_mangle]
pub extern fn array_pass(n: *const libc::uint32_t, len: libc::size_t) {
    let numbers = unsafe {
        assert!(!n.is_null());

        slice::from_raw_parts(n, len as usize)
    };
    for i in numbers.iter() {
        println!("{:?}", i);
    }
}

#[no_mangle]
pub extern fn sort_in_rust(nums: &[i32]) -> RubyArray {
    let mut nums2: Vec<&i32> = vec![];

    for i in nums {
        println!("{}", i);
        nums2.push(i);
    }
    RubyArray::from_vec(nums2)
}

#[no_mangle]
pub extern fn number_to_int_array() -> RubyArray {
    let mut nums: Vec<i32> = vec![];

    for i in 33..136 {
        nums.push(i);
    }
    RubyArray::from_vec(nums)
}

#[no_mangle]
pub extern fn sum(x: i32, y: i32) -> i32 {
    x + y
}

#[test]
fn it_works() {
    assert_eq!(sum(1, 2), 3);
}
